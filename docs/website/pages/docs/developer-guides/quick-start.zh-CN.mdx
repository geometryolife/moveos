# 快速入门

本小节将通过一个计数器例子来快速介绍 Rooch 的开发入门。

## 什么是计数器

计数器是一个计数的小程序，它包含一个初始值，我们可以通过一个递增指令，让它的值递增，从而达到计数的目的。

我们可以使用任何编程语言来实现这个小程序，这篇教程将使用 Move 语言来编写它，并且让它成功运行在 Rooch 上。

## 创建计数器项目

在我们创建计数器合约程序前，我们可以使用 Rooch 提供的 CLI 命令来初始化一个空项目：

```shell
rooch move new counter
```

详细的方法请参考[创建 Rooch Move 合约](./create-rooch-move-contract.zh-CN.mdx)。

为了更清楚的演示，我需要稍微修改 `Move.toml` 文件，让地址的别名（命名地址）更加清晰：

```toml
[addresses]
counter_addr = "0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6"
```

将 `[addresses]` 的 `counter` 改为 `counter_addr`。

接下来在 `sources` 目录里创建一个 `counter.move` 文件来编写我们的合约代码。

## 合约编写

```move
module counter_addr::counter {
    use moveos_std::account_storage;
    use moveos_std::context::Context;

    struct Counter has key {
        value: u64
    }

    fun init(ctx: &mut Context, account: &signer) {
        account_storage::global_move_to(ctx, account, Counter { value: 0 })
    }

    fun increase(ctx: &mut Context) {
        let counter = account_storage::global_borrow_mut<Counter>(ctx, @counter_addr);
        counter.value = counter.value + 1;
    }

    entry fun incr(ctx: &mut Context) {
        increase(ctx);
    }
}
```

通过简单的 21 行代码，就在 Rooch Move 上实现了简单的计数器功能。

接下来将详细介绍代码的每一行功能。

### 模块声明

在 Move 语言中，合约通常编写在一个个模块中，简单的合约通过一个模块就能完成，而复杂的合约可能由多个模块构成。我们的计数器合约非常简单，所以只有一个 `counter` 模块。

模块中，通常包含实现当前模块功能所需要的数据类型和函数。

```move
module counter_addr::counter {
```

在第 1 行中，我们用 `module` 关键字来声明一个 `counter` 模块。

在 Move 系的区块链系统中，模块是通过地址来唯一标识的，即一个地址只能拥有一个同类型的模块，无法多次发布同一个类型的模块。同一份合约可以被多个地址发布，为了在巨大的区块链系统中识别出合约模块到底是谁发布的，需要通过`地址`来唯一标识。

所以，声明一个 Move 模块的语法是 `module 地址::模块名`。

### 导入模块

```move
use moveos_std::account_storage;
use moveos_std::context::Context;
```

在第 2~3 行中，是导入模块的语句。要在 Rooch 上实现计数器合约，我们需要使用 Rooch 的某些功能库，此合约使用了 MoveOS 标准库提供的 `account_storage` 和 `context` 等功能模块。

### 定义数据结构

```move
struct Counter has key {
    value: u64
}
```

我们定义一个 `Counter` 类型的结构体用来记录计数值，结构体只包含一个 `u64` 类型的字段。

我们要将 `Counter` 类型的值记录到 Rooch 的全局存储中，所以需要给这个类型提供一个 `key` 能力，让 Move 能够通过`键`来查找数据。

### 初始化函数

```move
fun init(ctx: &mut Context, account: &signer) {
    account_storage::global_move_to(ctx, account, Counter { value: 0 })
}
```

Move 中提供一个特定的初始化函数 `init` 来自动初始化合约，确保合约发布后一些必需的操作已被执行。

例如，我们希望计数器合约一经发布，合约就自动为我们初始化好计数器，使它的计数值为 `0`。

第 9 行是 `init` 函数的函数签名，接受两个参数 `ctx` 和 `account`。

### 递增函数

接下来，我们要定义一个递增函数，每执行一次，就让计数器的值递增 `1`。

```move
fun increase(ctx: &mut Context) {
    let counter = account_storage::global_borrow_mut<Counter>(ctx, @counter_addr);
    counter.value = counter.value + 1;
}
```

第 13 行是 `increase` 函数的签名，接受一个上下文参数。

在第 14 行中，调用 Rooch 提供的账户存储的 `global_borrow_mut` 指令来获取 `Counter` 类型的可变引用，并将函数的返回值绑定到 `counter` 变量。借用到 `Counter` 的可变引用，我们就可以对他的值进行修改操作。

`global_borrow_mut` 函数接受一个上下文参数，和一个要借用 `Counter` 资源的地址参数，为了简单起见，我们直接使用发布计数器模块的地址作为借用方。

在第 15 行中，我们通过成员运算获取到 `Counter` 的字段值，并进行加一操作。

至此，我们就实现了计数器的递增逻辑。

### 入口函数

入口函数是由 `entry` 关键字修饰的函数。

出于安全考虑，在 Move 虚拟机中禁止了外部（命令行等）直接调用操作模块数据的函数，而是提供一种名为`入口函数`的方式来间接调用逻辑函数，入口函数是合约向外暴露的一种接口。

```move
entry fun incr(ctx: &mut Context) {
    increase(ctx);
}
```

如你所见，第 18~20 行，就是调用 `increase` 函数的入口函数。有了入口函数，我们就可以在命令行或其他客户端中执行计数器的递增操作了。

第 18 行是入口函数 `incr` 的函数签名，接受一个上下文参数。特别注意，这里的上下文参数是 Move VM 自动传递的参数，所以在命令行中调用 `incr` 函数时，不需要传递任何参数。

## 在 Rooch 的命令行界面中演示计数器程序

1. 首先启动 Rooch 的服务：

```shell
$ rooch server start

StoreConfig init store dir "/home/joe/.rooch/local/roochdb/rooch_store" "/home/joe/.rooch/local/roochdb/moveos_store"
2023-10-13T04:04:16.379378Z  INFO moveos_common::utils: set max open fds 45056
2023-10-13T04:04:17.614000Z  INFO rooch_rpc_server: RPC Server sequencer address: 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6
2023-10-13T04:04:17.614128Z  INFO rooch_sequencer::actor::sequencer: Load latest sequencer order 0
2023-10-13T04:04:17.614550Z  INFO rooch_rpc_server: RPC Server proposer address: 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6
2023-10-13T04:04:17.614974Z  INFO rooch_rpc_server: acl=Const("*")
2023-10-13T04:04:17.615380Z  INFO rooch_rpc_server: JSON-RPC HTTP Server start listening 0.0.0.0:50051
2023-10-13T04:04:17.615393Z  INFO rooch_rpc_server: Available JSON-RPC methods : ["eth_blockNumber", "eth_getBalance", "eth_gasPrice", "net_version", "rooch_listAnnotatedStates", "rooch_getBalance", "rooch_sendRawTransaction", "rooch_getAnnotatedStates", "rooch_getTransactionsByHash", "rooch_executeRawTransaction", "rooch_getEventsByEventHandle", "eth_getTransactionCount", "eth_sendTransaction", "rooch_executeViewFunction", "rooch_getBalances", "eth_getBlockByNumber", "eth_feeHistory", "rooch_listStates", "rooch_getTransactionsByOrder", "eth_sendRawTransaction", "rooch_getChainID", "eth_getTransactionByHash", "eth_getBlockByHash", "eth_getTransactionReceipt", "eth_chainId", "eth_estimateGas", "rooch_getStates"]
```

2. 开启另一个终端，并切换到 `counter` 项目的根目录，编译合约：

```shell
$ rooch move build

UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
UPDATING GIT DEPENDENCY https://github.com/rooch-network/rooch.git
INCLUDING DEPENDENCY MoveStdlib
INCLUDING DEPENDENCY MoveosStdlib
INCLUDING DEPENDENCY RoochFramework
BUILDING counter
Success
```

3. 发布计数器合约到 Rooch 上：

```shell
......
Publish modules to address: 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6
{
  "sequence_info": {
    "tx_order": "0",
    "tx_order_signature": {
      "auth_validator_id": "0",
      "payload": "0x003c988e0674b1c83fc01dcd6ed91f5fc1229905cdfc2b05355529e05b6eb19542ba634898496e4cd9b3c37f983fd7d6a066834d1b192cc4b22ce3e3c8e3dfa50cff7601c5cb4b3728059c9de799e94d7f47d6e32ab1cdeef3c96264de23a58103"
    },
    "tx_accumulator_root": "0xd59793bd681a120c201d6c69d880812184b2409a9dde53474aea97d57fe5e658"
  },
  "execution_info": {
    "tx_hash": "0xfa2b589b718951f3acb4e23a43579947879cff95f11f2e19a552a39fe7ede649",
    "state_root": "0x9679155aa61bf01ace2bb370ddea5c36e328631d18b747e065c611ea038a536a",
    "event_root": "0xd58502028bbdee763851bdb1d42554926a85ef1144b5706e760363f48d5b103f",
    "gas_used": 1604134,
    "status": {
      "type": "executed"
    }
  },
......
```

看到输出结果的 `status` 中出现 `executed`，说明计数器合约已经成功发布，并且初始化好了计数器。

4. 我们使用 Rooch 提供的资源查找命令来获取 `Counter` 资源的相关信息。

语法是 `rooch resource --address 发布资源的地址 --resource 资源的类型`：

```move
$ rooch resource --address 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6 --resource 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter

{
  "state": {
    "value": "0x0000000000000000",
    "value_type": "0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter"
  },
  "move_value": {
    "abilities": 8,
    "type": "0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter",
    "value": {
      "value": "0"
    }
  }
}
```

注意 `value` 属性，可以看到在 `Counter` 资源的输出信息中，`Counter` 的字段值 `value` 确实是 `0`。

5. 接着我们调用计数器的递增函数：

语法是 `rooch move run --function 模块发布的地址::模块名::入口函数名 --sender-account 发送当前交易的地址`。

> 注意：区块链系统中，执行某些操作通常是通过向区块链系统中发送某个交易来执行相应的操作。

```shell
$ rooch move run --function 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::incr --sender-account 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6
```

6. 再次查看计数器的值是否是我们预期的值：

```shell
$ rooch resource --address 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6 --resource 0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter
{
  "state": {
    "value": "0x0100000000000000",
    "value_type": "0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter"
  },
  "move_value": {
    "abilities": 8,
    "type": "0x796736e1937532c985ca39da1f49e7d4acc2bf17e8814d87f21445199bf04bd6::counter::Counter",
    "value": {
      "value": "1"
    }
  }
}
```

如你所见，`Counter` 的 `value` 字段的值确实已经更新为 `1` 了。

至此，你已经了解了如何在 Rooch 中编写合约以及如何在命令行中调用合约了。

接下来，我们增加一点点难度，我们将演示如何在前端中运行和使用计数器合约程序。
